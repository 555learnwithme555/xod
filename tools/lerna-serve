#!/usr/bin/env node
/*
 */
const path = require('path');
const async = require('async');
const program = require('commander');
const escapeArgs = require('command-join');
const chalk = require('chalk');
const PackageUtilities = require('lerna/lib/PackageUtilities');
const ChildProcessUtilities = require('lerna/lib/ChildProcessUtilities');
const RunCommand = require('lerna/lib/commands/RunCommand');

const exceptLast = func => (value, idx, self) => 
  ((idx === self.length - 1) ? value : func(value));

function pipeOutput(source, target, label) {
  const prefix = chalk.magenta(`[${label}] `);

  let lineBuffer = [];

  source.on('data', data =>
    data
      .split('\n')
      .map(exceptLast(l => l + '\n'))
      .forEach(pipe)
  );

  function pipe(data) {
    lineBuffer.push(data);
    if (data.endsWith('\n')) {
      target.write(prefix);
      target.write(lineBuffer.join(''));
      lineBuffer = [];
    }
  }
}

/*
 */

class ServeCommand extends RunCommand {
  initialize(callback) {
    super.initialize((err, result) => {
      if (err) {
        callback(err);
        return;
      }
    });

    if (this.flags.withDeps) {
      this.logger.info('Including package dependencies');
      const graph = PackageUtilities.getPackageGraph(this.packages);
      const concat = (a, b) => a.concat(b);

      const packageWithDeps = packageGraphNode =>
        packageGraphNode.dependencies
          .map(pkgName => graph.get(pkgName))
          .map(packageWithDeps)
          .reduce(concat, []).concat([packageGraphNode]);

      const unique =
        (value, index, self) => 
          self.map(pkg => pkg.name).indexOf(value.name) === index;

      this.packagesWithScript = this.packagesWithScript
        .map(pkg => graph.get(pkg.name))
        .map(packageWithDeps)
        .reduce(concat, [])
        .map(graphNode => graphNode.package)
        .filter(unique)
        .filter((pkg) => pkg.scripts && pkg.scripts[this.script]);
    }

    callback(null, true);
  }

  runScriptInPackages(callback) {
    async.parallelLimit(this.packagesWithScript.map((pkg) => (cb) => {
      this.runScriptInPackage(pkg, cb);
    }), 100, callback);
  }

  runScriptInPackage(pkg, callback) {
    const opts = {
      cwd: pkg.location,
      env: process.env
    };

    const command = `npm run ${this.script} ${escapeArgs(this.args)}`;
    const proc = ChildProcessUtilities.exec(command, opts, callback);

    pipeOutput(proc.stdout, process.stdout, pkg.name);
    pipeOutput(proc.stderr, process.stderr, pkg.name);
  }
}

/*
 * Make a simple CLI runner of the SortedRunCommand.
 */
program
  .version('0.0.0')
  .arguments('<npm-command> [package]')
  .option('-t, --tree', 'Run command on dependencies first')
  .action((cmd, pkg) => {
    const flags = {
      scope: pkg,
      withDeps: program.tree,
    };

    const lernaCommand = new ServeCommand([cmd], flags);

    // extend path with root-level node_modules to access build tools
    // binaries
    process.env['PATH'] = path.resolve(__dirname, '..', 'node_modules', '.bin') +
      ':' + process.env['PATH'];

    lernaCommand.run();
  });

program.parse(process.argv);
if (program.args.length === 0) {
  console.log(program.help());
}

// vim:ft=javascript
